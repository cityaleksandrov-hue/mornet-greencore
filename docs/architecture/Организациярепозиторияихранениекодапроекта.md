# Организация репозитория и хранение кода проекта

### Монорепозиторий vs отдельные репозитории (polyrepo)

Проект **MorNet/GreenCore** включает множество взаимосвязанных компонентов – фронтенды (Vue Admin и React Public), несколько микросервисов (NestJS-сервисы ядра), смарт-контракты, шлюзы и пр. Встает вопрос: хранить весь код в одном монолитном репозитории или разделить по нескольким репозиториям (например, по сервисам) внутри GitLab-группы. Согласно современным практикам, единый **монорепозиторий** часто предпочтителен для подобных комплексных платформ, где компоненты тесно связаны и требуют совместной доработки[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=%E2%9C%85%20When%20to%20Use%20a,Monorepo)[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%9B%D0%B5%D0%B3%D1%87%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D1%8C%20%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3%20%D0%BA%D0%BE%D0%B4%D0%B0%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9). Монорепо означает, что весь код хранится в одном репозитории, но структурирован по папкам (модулям) – например, `apps/` для приложений и `packages/` или `libs/` для общих библиотек[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=my,Reusable%20logic%20or%20hooks). Альтернатива – **мультирепозиторий** (polyrepo), когда каждый сервис или модуль живёт в своем репозитории, объединённые в группу. Рассмотрим плюсы и минусы обоих подходов применительно к нашему проекту.

**Преимущества монорепозитория:** единое хранение упрощает совместную работу и интеграцию. Все зависимости и пакеты находятся в одном месте, облегчая управление версиями и обновлениями для всех частей системы[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%9B%D0%B5%D0%B3%D1%87%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D1%8C%20%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3%20%D0%BA%D0%BE%D0%B4%D0%B0%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9). Общий репозиторий обеспечивает целостность кода – все модули видны команде, что улучшает понимание системы и сотрудничество между направлениями разработки[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%9B%D0%B5%D0%B3%D1%87%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D1%8C%20%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3%20%D0%BA%D0%BE%D0%B4%D0%B0%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9). Легче поддерживать **единые стандарты кодирования, линтинга и форматирования** во всех сервисах. Настройка **единого CI/CD-пайплайна** для всего проекта также упрощается – можно запускать сборку и тесты всех компонентов совместно либо выборочно, с централизованным управлением процессом деплоя[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%9B%D0%B5%D0%B3%D1%87%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D1%8C%20%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3%20%D0%BA%D0%BE%D0%B4%D0%B0%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9). За счет общего репозитория проще выполнять **сквозное рефакторинг** и доработки, затрагивающие сразу несколько модулей, в рамках одного изменения (PR)[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%BA%D0%BE%D0%B4%D0%B0%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9%20%D0%B7%D0%B0%D1%82%D1%80%D0%B0%D0%B3%D0%B8%D0%B2%D0%B0%D0%B5%D1%82%20%D0%BD%D0%B5%D1%81%D0%BA%D0%BE%D0%BB%D1%8C%D0%BA%D0%BE%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%B5%D0%BD%D1%82%D0%BE%D0%B2)[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=If%20everyone%20can%20agree%20on,involves%20coordination%20becomes%20much%20easier). Практика показывает, что для связанных приложений (фронт+бэк+общие библиотеки) монорепо экономит время и силы разработки[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=%E2%9C%85%20When%20to%20Use%20a,Monorepo). Разработчики отмечают, что с инструментами вроде Turborepo или Nx монорепозиторий позволяет **повторно использовать код (компоненты, утилиты)**, держать единые конфиги (ESLint, Prettier и т.д.) и собирать/развёртывать всё из одной_PIPELINE[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=My%20Personal%20Take%20As%20a,They%20let%20me). Это особенно актуально для нашего проекта, где планируется единый UI-кит для двух фронтендов и общие схемы (OpenAPI, Zod) для сервисов.

**Недостатки монорепозитория и их митигирование:** основная сложность – масштабируемость и рост объема кода. В большом монорепо со временем могут увеличиться время сборки и тестов, сложнее навигация по проекту, чаще возникают конфликты при слиянии изменений, если много разработчиков[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%9D%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D1%82%D0%BA%D0%B8%3A)[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%92%20%D0%BC%D0%BE%D0%BD%D0%BE%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D1%85%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D1%87%D0%B8%D0%BA%D0%B8%20%D0%BC%D0%BE%D0%B3%D1%83%D1%82%20%D1%86%D0%B5%D0%BD%D1%82%D1%80%D0%B0%D0%BB%D0%B8%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE,%D0%92%20%D0%B1%D0%BE%D0%BB%D1%8C%D1%88%D0%B8%D1%85%20%D0%BC%D0%BE%D0%BD%D0%BE%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F%D1%85%20%D1%81%D0%B1%D0%BE%D1%80%D0%BA%D0%B0%20%D0%B8). Однако текущая команда и проект по размеру *не* столь огромны, чтобы эти проблемы перевешивали выгоды. Кроме того, современные инструменты устраняют многие технические сложности: например, Nx предоставляет кэширование и запуск только затронутых сборок, что решает проблему долгих билдов и тестов[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=Monorepos%20have%20a%20lot%20of,your%20monorepo%20grows%20are%20interpersonal). В компании Nx отмечают, что при грамотном использовании таких тулов технические проблемы большого монорепо полностью решаемы, а пределом становятся скорее организационные факторы (согласование процессов в команде)[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=Monorepos%20have%20a%20lot%20of,your%20monorepo%20grows%20are%20interpersonal). Нам необходимо заранее договориться о правилах работы в одном репозитории – определить ответственность за разные модули, соглашения по веткам и code review, а также продумать структуру папок и naming, чтобы избежать хаоса[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=In%20order%20for%20teams%20to,to%20work%20in%20separate%20repositories)[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=,managed%3F%20Who%20is%20responsible%20for). В нашем случае уже запланирована структура монорепо на основе Turborepo/Nx (см. дорожную карту на октябрь), что говорит в пользу этого подхода.

**Преимущества раздельных репозиториев:** изоляция сервисов и независимость команд. Каждый микросервис в своём репозитории позволяет разрабатывать и выпускать его автономно, с отдельным циклом релизов, не мешая параллельной работе над другими модулями[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=,boundaries%20are%20needed%20between%20codebases)[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%9F%D1%80%D0%B5%D0%B8%D0%BC%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B0%3A). Это может снизить риски пересечения изменений и упростить понимание конкретного сервиса (репозиторий меньше по коду). Также мультирепо даёт гибкость в инструментах – разные CI/CD процессы или технологии для разных компонентов при необходимости[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D1%81%D1%81%D1%8B%20CI%2FCD%20%D0%B4%D0%BB%D1%8F%20%D1%80%D0%B0%D0%B7%D0%BD%D1%8B%D1%85%20%D0%BC%D0%BE%D0%B4%D1%83%D0%BB%D0%B5%D0%B9). Однако в контексте нашего проекта эти плюсы не столь критичны: все части платформы разрабатываются синхронно и направлены на единый релиз MVP, а команды тесно взаимодействуют (не **полностью** независимые стримы разработки).

**Недостатки мультирепозитория:** возникают сложности с синхронизацией версий и зависимостей между сервисами[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%B8%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D0%BF%D0%BE%20%D0%B2%D1%81%D0%B5%D0%BC%D1%83%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%83). Общий код (например, модели данных, утилиты) может дублироваться в нескольких репозиториях, либо потребует завести отдельные библиотечные репо и пакеты – это увеличивает сопровождение и риск рассинхронизации API между компонентами[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%B8%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D0%BF%D0%BE%20%D0%B2%D1%81%D0%B5%D0%BC%D1%83%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%83). Интеграция тоже усложняется: нужно настроить механизм совместного тестирования и деплоя, регулярно собирать все части вместе, что требует дополнительных усилий и координации между командами[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%B8%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D0%BF%D0%BE%20%D0%B2%D1%81%D0%B5%D0%BC%D1%83%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%83). В случае отдельного репозитория на каждый микросервис каждое изменение, затрагивающее несколько сервисов (например, изменение структуры токена или контракта), потребует нескольких PR в разные репозитории и тщательного управления версиями, вместо одного атомарного изменения в монорепо. Это замедляет развитие функциональности и повышает вероятность ошибок интеграции[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=If%20every%20project%20is%20placed,the%20repositories%20in%20the%20organization). Кроме того, поддержание единых стандартов кодирования и инфраструктуры в разных репозиториях сложнее – приходилось бы дублировать настройки ESLint, Prettier, Docker/Helm и др. или делать репозиторий-шаблон и следить за его обновлением везде[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D1%82%D1%8C%20%D0%B4%D0%BE%D0%BF%D0%BE%D0%BB%D0%BD%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D1%8B%D1%85%20%D1%83%D1%81%D0%B8%D0%BB%D0%B8%D0%B9.%20,%D0%B8%20%D0%BF%D1%80%D0%B0%D0%BA%D1%82%D0%B8%D0%BA%D0%B8%20%D0%BF%D0%BE%20%D0%B2%D1%81%D0%B5%D0%BC%D1%83%20%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D1%83). Для нашего проекта, который ценит **прозрачную интеграцию и частое комплексное тестирование (E2E)**, такой разрозненный подход менее удобен.

### Рекомендуемая стратегия: монорепозиторий с модульной структурой

Учитывая все факторы, предлагаем использовать **монорепозиторий** для хранения кода MorNet/GreenCore. Это соответствует и плану работ (создание репозитория-монорепо с Turborepo/Nx) и текущим best practices. Команда у нас относительно небольшая, а компоненты проекта тесно связаны, поэтому единый репозиторий будет удобнее[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%92%D1%8B%D0%B1%D0%BE%D1%80%20%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D1%82%20%D0%BE%D1%82%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%B0,%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B8%D1%82%D1%8C%20%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5%20%D0%B8%20%D0%BD%D0%B0%D0%B4%D0%B5%D0%B6%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). Мы нацелены на частую интеграцию компонентов (MVP требует сквозного сценария «станция → минт токенов → распределение → обмен → банк»), что также аргумент в пользу монорепо[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%92%D1%8B%D0%B1%D0%BE%D1%80%20%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D1%82%20%D0%BE%D1%82%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%B0,%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B8%D1%82%D1%8C%20%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5%20%D0%B8%20%D0%BD%D0%B0%D0%B4%D0%B5%D0%B6%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5). Отдельные репозитории могли бы иметь смысл, если бы части системы развивались абсолютно независимо, разными большими командами, с редкими точками соприкосновения – но это не наш случай[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=,boundaries%20are%20needed%20between%20codebases).

**Структура монорепозитория:** Проект будет разбит на папки по логическим модулям внутри одного GitLab-проекта. Можно использовать подход Nx/Turborepo с директориями `apps/` и `libs/` (или аналогично):

- `apps/admin-ui` – фронтенд Admin (Vue 3).
- `apps/public-ui` – фронтенд Public (Next.js/React).
- `apps/identity-service`, `apps/wallet-service`, `apps/token-engine`, ... – каталоги для каждого ключевого сервиса (NestJS).
- `apps/oracle-service` – сервис-оракул/блокчейн адаптер.
- `apps/edge-agent` (опционально) – код edge-агента (если пишется на Node/TS или другом ЯП; при сильных различиях возможен и отдельный репо).
- `packages/shared` или `libs/common` – общие библиотеки и утилиты (например, модели данных, клиент для блокчейна, OpenAPI-схемы/типизация Zod, общие константы и типы для микросервисов).
- `packages/ui-kit` – общий UI-kit или дизайн-система (компоненты, темы, стили), переиспользуемые между Vue и React приложениями (может быть реализовано на уровне дизайн-токенов или через Storybook).
- `packages/smart-contracts` – код смарт-контрактов (Hardhat проект для ERC-1155/20), если планируется хранить его вместе (альтернативно, смарт-контракты могут быть в отдельном репо, но в монорепо удобно держать ABI и типы для них).
- Дополнительные директории: `infra/` для инфраструктурных файлов (Dockercompose, Helm charts, K8s манифесты) – хотя их можно хранить и в отдельном repo для GitOps, на этапе разработки их наличие в монорепо упростит синхронность изменений.

Такая организация обеспечит **модульность** внутри монорепозитория – каждый сервис или приложение изолирован в своей папке, но при этом может легко пользоваться общим кодом из `libs/` без дублирования. Например, структуры БД и DTO, описанные в одном месте, будут импортироваться всеми сервисами, что гарантирует согласованность. Фронтенды смогут использовать единые компоненты/константы (например, список токенов, форматирование данных) из общего пакета, не копируя их. Мы также настроим **скрипты сборки и тестирования** для каждого модуля отдельно, чтобы можно было развертывать и проверять их независимо при разработке. Инструменты Nx/Turborepo помогут организовать зависимость между проектами и выполнять только затронутые задачи при изменениях, ускоряя CI. Например, изменение в коде Wallet-сервиса не будет триггерить сборку фронтенда, если между ними нет прямой зависимости, благодаря анализу зависимости графа и кэшированию результатов сборок[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=Monorepos%20have%20a%20lot%20of,your%20monorepo%20grows%20are%20interpersonal).

**Управление версиями и релизами:** В монорепо мы можем использовать единый versioning подход (например, semver для всего продукта или independent versioning для пакетов при необходимости). Но на этапе MVP достаточно объединенного управления – все сервисы развиваются в унисон. При деплое в Kubernetes каждая служба все равно будет собираться в свой Docker-образ, так что монорепозиторий не мешает раздельному развертыванию. С помощью Nx можно настроить генерацию версий пакетов или Docker-образов автоматически на основе изменений, что упростит выпуск новых версий сервисов из общего репозитория.

**Доступ и права:** Если возникнет необходимость ограничить доступ к некоторым частям (например, финансовый модуль или комплаенс), в GitLab можно настроить Code Owners и защиту веток по каталогу. Таким образом, монорепо не означает, что все разработчики будут менять все подряд – разделение ответственности сохраняется через процессы код-ревью и назначение ответственных за конкретные директории.

**Возможные исключения:** Единственный компонент, который потенциально стоит вынести в отдельный репозиторий – это **Edge-агент**, если он пишется на совершенно другом языке (например, C/C++ для контроллеров PLC) или разрабатывается другой командой. В таком случае его можно хранить отдельно и подключать через пакет или субмодуль. Однако если Edge-агент реализован на Node/Python и тесно интегрируется с остальными сервисами (отправляет телеметрию в MQTT/REST), имеет смысл включить его в монорепо для унификации конфигурации и совместного тестирования.

### Итоги и обоснование выбора

С учётом масштабов проекта и необходимости тесной интеграции модулей, **монорепозиторий с модульной структурой** – оптимальное решение. Он обеспечит **“единый источник истины”** для кода всей платформы и облегчит координацию изменений между компонентами[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%9C%D0%BE%D0%BD%D0%BE%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D0%B8%20%D0%BC%D0%BE%D0%B3%D1%83%D1%82%20%D0%BF%D1%80%D0%B5%D0%B4%D0%BB%D0%BE%D0%B6%D0%B8%D1%82%D1%8C%20%D0%B5%D0%B4%D0%B8%D0%BD%D1%8B%D0%B9%20%D0%B8%D1%81%D1%82%D0%BE%D1%87%D0%BD%D0%B8%D0%BA,%D1%82%D1%80%D0%B5%D0%B1%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F%D0%BC%20%D0%BA%20%D0%BC%D0%B0%D1%81%D1%88%D1%82%D0%B0%D0%B1%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E%20%D0%B8%20%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D1%80%D0%B6%D0%BA%D0%B5)[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=If%20everyone%20can%20agree%20on,involves%20coordination%20becomes%20much%20easier). Команда сможет работать синхронно над разными частями, сразу видя влияние правок на всю систему. Это особенно важно для соблюдения принципа **прозрачной токеномики** – любые изменения контрактов, индексов, расчётов сразу отражаются во всех зависимых модулях. Монорепо упрощает внедрение сквозных функций (End-to-End) и поддержание согласованности бизнес-логики. При этом потенциальные минусы монорепо (конфликты, время сборки) на нашем этапе контролируемы и смягчаются использованием **Nx/Turborepo** и четких командных соглашений.

Для сравнения, крупные компании в России успешно используют монорепозитории для схожих задач – например, Яндекс и VK хранят основные сервисы единым репо для лучшей интеграции команд[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%BA%D0%BE%D0%BE%D1%80%D0%B4%D0%B8%D0%BD%D0%B0%D1%86%D0%B8%D0%B8%20%D0%B8%20%D1%81%D0%BE%D0%B2%D0%BC%D0%B5%D1%81%D1%82%D0%BD%D0%BE%D0%BC%D1%83%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8E%20%D0%BA%D0%BE%D0%B4%D0%B0). Наша цель – быстро доставить работающий MVP и подготовиться к масштабированию, поэтому ставка на монорепо обоснована потребностью в скорости разработки и интеграции. В перспективе, если проект значительно вырастет (десятки микросервисов, большие раздельные команды, разные циклы релизов), стратегию можно будет пересмотреть и **разбить монорепо на несколько** (например, фронтенды отдельно, смарт-контракты отдельно, и т.д.) или выделить независимые модули в свои репозитории[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=Somewhere%20between%20the%20single%20monorepo,will%20be%20working%20in%20them). Но на текущем этапе монорепозиторий даст максимальную выгоду в консолидации разработки. Как отмечается в аналитике, при старте нового проекта с множеством связанных частей монорепо позволяет сэкономить массу времени, тогда как множественные репозитории оправданы лишь при **очень** больших командах и разноцикловых продуктах[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=project%20structure%2C%20and%20long)[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%92%D1%8B%D0%B1%D0%BE%D1%80%20%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D1%82%20%D0%BE%D1%82%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%B0,%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B8%D1%82%D1%8C%20%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5%20%D0%B8%20%D0%BD%D0%B0%D0%B4%D0%B5%D0%B6%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

**Заключение:** проект MorNet/GreenCore будет организован как монорепозиторий (на собственном GitLab) с разделением на внутренние модули/пакеты. Такой подход обеспечит единообразие и упрощение процессов разработки, тестирования и деплоя для первой версии системы, что критично для успешного запуска пилота. Мы аргументированно выбираем монорепо, опираясь на современные best practices и потребности проекта, и планируем внедрить его с помощью инструментов Nx/Turborepo для эффективного управления кодовой базой[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=My%20Personal%20Take%20As%20a,They%20let%20me)[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=Monorepos%20have%20a%20lot%20of,your%20monorepo%20grows%20are%20interpersonal). Это решение поддержит прозрачность и качество кодовой базы, облегчая как текущую работу команды, так и дальнейшее масштабирование платформы.

**Источники:** выбранная стратегия соответствует рекомендациям индустрии. Монорепозитории способствуют объединению зависимостей, единому CI/CD и повышают консистентность кода[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=,%D0%9B%D0%B5%D0%B3%D1%87%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B4%D0%B8%D1%82%D1%8C%20%D1%80%D0%B5%D1%84%D0%B0%D0%BA%D1%82%D0%BE%D1%80%D0%B8%D0%BD%D0%B3%20%D0%BA%D0%BE%D0%B4%D0%B0%2C%20%D0%BA%D0%BE%D1%82%D0%BE%D1%80%D1%8B%D0%B9), что подтверждается опытом крупных проектов. В то же время мы учитываем риски масштаба и используем инструменты для их снижения[nx.dev](https://nx.dev/docs/concepts/decisions/overview#:~:text=Monorepos%20have%20a%20lot%20of,your%20monorepo%20grows%20are%20interpersonal). Как сказано в руководствах, для небольших и средних команд с тесно связанными сервисами монорепо удобнее, тогда как мультирепо имеет смысл при автономных командах и редкой интеграции[timeweb.cloud](https://timeweb.cloud/tutorials/microservices/otdelnye-repozitorii-ili-monorepozitorii#:~:text=%D0%92%D1%8B%D0%B1%D0%BE%D1%80%20%D1%81%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D0%B8%20%D0%B7%D0%B0%D0%B2%D0%B8%D1%81%D0%B8%D1%82%20%D0%BE%D1%82%20%D1%80%D0%B0%D0%B7%D0%BC%D0%B5%D1%80%D0%B0,%D0%BE%D0%B1%D0%B5%D1%81%D0%BF%D0%B5%D1%87%D0%B8%D1%82%D1%8C%20%D0%B1%D1%8B%D1%81%D1%82%D1%80%D0%BE%D0%B5%20%D0%B8%20%D0%BD%D0%B0%D0%B4%D0%B5%D0%B6%D0%BD%D0%BE%D0%B5%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B5%D1%80%D1%82%D1%8B%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)[dev.to](https://dev.to/md-afsar-mahmud/monorepo-vs-polyrepo-which-one-should-you-choose-in-2025-g77#:~:text=%E2%9C%85%20When%20to%20Use%20a,Monorepo). Наш выбор подкреплен этими аргументами и соответствует плану развития GreenCore.